# Soft-CPU

## Обратная польская записать

(3+5)\*10 == 35+10\*
тогда

```c
push 3
push 5
add
push 10
in
nul
out
end
```

## Пишем калькулятор руками на обратной польской

используем стек и функцию fscanfs()
тогда можно разбирать строку по командам
 _нужно разбирать по командам строки вида_

```c
push 3 push 5 add push 10 in nul out end
```

_для того чтобы работало быстрее можно заменить команды числами_
обязательно использовать **enum**
тогда наш файл команд будет выглядеть как

```c
1 3
1 5
2
1 10
3
4
0
```

_теперь разобьем нашу прогу на две части, тем самым у нас будет медленный ввод и быстрое выполнение_
тогда у нас будет стек где будут команды и значение
мы должный перескакивать через 1 или 2 ячейки, так как за командой ввода следует ввод

### Теперь введем еще одну программу и назовем ее компиляцией, asm

будем преобразовывать строки вида в команды

```c
push 3
push 5
add
push 10
in
nul
out
end
```

в команды типа

``` 1 3
1 5

1 10
3
4
0
```

Таким образом мы один раз будет создавать быстрой код, исполняемый многократно

### А теперь напишем disasm

это штука которая по исходному коду генерит исходный код

_Есть такой disasm написанный русским **IDA** _
он дисассемблит код и пытается восстановить связный код на с
 ***

## Теперь дальше

программа запишет команды и данные в массив и запишет его один разом на диск **fwrite**
при последующем чтение необходимо читать используя **%wd** для побитового режима
_для удобства просмотра и редактирования бинарников надо скачать и использовать редактор бинарных файлов_

### Убедимся что данные действительно совпадают

запишем данные в текстовый и бинарный файл и сверим вручную 

#### листинг

бинарный файл сделанный для дебага кода в HEX виде

| адрес команды | данные      | данные      | эквивадент |
| :------------ | :---------: | :---------: | :--------- |
| 0000          | 01 00 00 00 | 03 00 00 00 | push 3     |
| 0008          | 01 00 00 00 | 05 00 00 00 | push 5     |
| 0010          | 02 00 00 00 |             | add        |

#### Представим это в виде массива в памяти

_запишем команды ячейкой размера **1 байт**_
все данные же будут иметь фиксированные размер, допустим 4 бита
01 | 01 00 00 00 | 03 00 00 00 и тд
назовем это **ip/pc** где pc - стек, а ip-позиция в нем
тогда код для доступа

```c
code[ip]
//доступ по
*(int*)(code+ip+1)
ip += 1 + sizeof(int)
```

итого нужно сделать неравномерный код для хранения стека команд

## Итого нужно сделать soft-CPU

>Надо написать процессор. Который состоит из:

### Код

1. Компилятор (делает из кода юзера код asm)
   * строковый
   * байт-код
   * неравномерный байт-код
2. Процесор (исполняет неравномерный код из памяти)
   * из байт-кода
   * из неравномерного кода
3. Добавляем фичи(команды для юза)
   * jmp (метки)
   * оперативка
   * регистры
   * указатели
   * ввод вывод

### Тесты

1. Простые операции
   * сложение
   * и т.д
2. Линейное уравнение
3. Квадратное уравнение
4. Ипользование условий

>ну и добавить фичи!!!

## Набираемся смелости и добавляем возможность процессору решать квадратные уравнение

Для этого нудно сделать команду вычисления корня и как-то хранить дискриминант и корень

_для решения квадратного уравнения заведем **переменные - регистры**_

тогда наш код будет таким где

```c
push 5
push ax // ax добавим в стек
pop bx // pop из стека и положить в bx
```

что в байт-коде будет

```c
1 5
1 1 1 // где 1 - номер команды 1 - говорит что это регистр 1 - говорит что это регистр с номером 1
2 1 2
```

### А что делать если у нас много данных

Запишем данные в оперативную память. Так будем иметь номер по которому лежит число - те указатель

```c
push [50] // создаем массив где 50 указатель на элемент в оперативке // просто отдельный массив
push [ax]
```

в байт-коде

```c
1 2 50 // где второй элемент это формат
2 2 1 // push оперативка регистр 1
```

#### пример

```c
push 49 // тут формат команды 0 - стек
pop ax // тут формат 1 - регистр
push [ax] // тут формат команды 2 - элемент из оперативки
push [bx+4] // тут формат команды 4 в байт *1 4 2 4*
```

_тут мы просто пихаем в стек 49, достаем и пишем в регистр ax
далее просто пишем в стек элемент ax из оперативки_

## Ну а теперь прямо жесть. Введем условия - If

Рассмотрим код

```c
push 1
pop ax // ax = 1

push ax
push ax
mul
out // out(ax^2)

push ax
push 1
add
pop ax // ax++

jmp // goto
```

теперь рассмотрим как это выглядит в байт-коде в виде стека

```b
1 1 // ячейка 0 и 1
10 1 // 2 и 3
11 1 // вот и наша 4, те будет исполняться команда 11 при переходе на 4
11 1
2
2
11
1
1
1
4
10
1
20 4 // прыгнуть на место 4, те на 4 команд
```

Но как вычислить номер команды 4
Все просто. Сделайте код и поставьте вместо 4 любое плохое число, как пример -1. После компиляции посмотрите на байт-код и определите место в стеке команд, куда нужно перейти.

Можно ip = 4 = pc[ip + 1]
 ***

### Метки

В наш код добавим метки вида

```с
:1 // метка 1
```

Эти метки не переходят в байт-код, а лишь вычисляются при компиляции.
Они будут заменены при компиляции на номер строки. Тогда такой код будет обработан и в него будет записан номер строки вместо метки

```asm
jmp :1
```

заменится на средствами компилятора, те ассемблера

```bin
jmp 4
```

***

### Логика компилятора

Идеи по коду и пропускаем при нумерации команд.
Заведем массив, где будем хранить сами метки. Тогда просто при появлении метки номер 1.

_**Внимание** код в ASCII_
таким образом метки нужно привести к числам

```c
labels[str[1] - '0'] = cur_adress; // запишет в массив с метками метку с номером 1 и содержит текущий адрес
```

полезно вывести появление метки **листинг**

#### Что делать если метка ниже по коду?

Приведем компиляции 2 раза. Построим массив меток при первом проходе. Далее при втором проходе уже расставим корректные адреса переходов по уже построенному массиву меток.

**Массив меток** изначально заполнен **-1** те, при первом проходе у нас у меток будут адреса -1. При втором проходе используем уже созданный массив и заменим все -1 на корректный адреса.

>Важно!

Используем одну и туже функцию компиляции для повторного прохода

***

### Ну а теперь сами If

Разберем на примере

```с
push 1
pop ax // ax = 1
:1 // метка 1
push ax
push 100
ja :2 // берем последние 2 числа из стека. Сравниваем и если больше то переходим на метку 2

push ax
push ax
mul
out // out(ax^2)

push ax
push 1
add
pop ax // ax++

jmp :1// переход на метку 1
```

есть 3 различный if:

```c
// jump above
ja // if >
// jump below
jb // if <
// jump equal
je // if ==
```

***

#### Как выйти из программы

```c
end // выход
```

***

#### Intresting

[посмотри](http://allegedly.petebevin.com/opcodes.html)

>команды acm, но интересней

***

## Пока все, короч...

>Записано ПО "Деду"
