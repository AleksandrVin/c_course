# Soft-CPU

## Обратная польская записть

(3+5)\*10 == 35+10\*
тогда

```c
push 3
push 5
add
push 10
in
nul
out
end
```

## Пишем калькулятор руками на обратной польской

используем стек и функцию fscanfs()
тогда можно разбирать строку по командам
 _нужно рабирать по командам строки вида_

```c
push 3 push 5 add push 10 in nul out end
```

_для того чтобы работало быстрее можно заменить команды числами_
обязательно юзать **enum**
тогда наш файл команд будет выглядеть как

```c
1 3
1 5
2
1 10
3
4
0
```

_теперь разобьем нашу прогу на две части, тем самым у нас будет медленный ввод и быстрое выполнение_
тогда у нас будет стек где будут команды и заначение 
мы должный перескакивать через 1 или 2 ячейки, так как за комнадой ввода следует ввод 

### Теперь введем еще одну программу и назовем ее компиляцией , asm

будем преобразовывать строки вида в команды

```c
push 3
push 5
add
push 10
in
nul
out
end
```

в команды типа

``` 1 3
1 5
2
1 10
3
4
0
```

таким образом мы единажды будет создавать быстрой код, исполняемый многократно

### А теперь напишем disasm

это штука которая по исходному коду генерит исходный код

_есть такой disasm написаный русским **IDA** _
он дисассемблит код и пытаеся востановить связный код на с
 ***

## Теперь дальше

программа запишет команды и данные в массив и запишет его один разом на диск **fwrite**
при последующем чтение необходимо читать используя **%wd** для побитового режима
_для удобства просмотра и редактирования бинарников надо скачать и использовать редактор бинарных файлов_

### Убедимся что данные действительно совпадают

запишем данные в тектовый и бинарный файл и сверим вручную 

#### листинг

бинарный файл сделаный для дебага кода в 16 виде

| адрес команды | данные | данные | эквивадент
| :---- | :-------: | :---------: | :---- |
| 0000 | 01 00 00 00 | 03 00 00 00 | push 3
| 0008 | 01 00 00 00 | 05 00 00 00 | push 5
| 0010 | 02 00 00 00 | | add

#### Представим это ввиде массива в памяти

_запишеи команды ячейкой размера **1 байт**_
все данные же будут иметь фиксированные размер, допустим 4 бита
01 | 01 00 00 00 | 03 00 00 00 и тд
назовем это **ip/pc** где pc - стек, а ip-позиция в нем
тогда код для доступа

```c
code[ip]
//доступ по
*(int*)(code+ip+1)
ip += 1 + sizeof(int)
```

итого нужно сделать неравномерный код для хранения стека команд

## Итого нужно сделать soft-CPU

>Надо написать процессор. Который состоит из:

### Код

1. Компилятор ( делает из кода юзера код asm)
   * строковый
   * байт код
   * неравномерный байт код
2. Процесор ( исполняет неравномерный код из памяти )
   * из байт кода
   * из неравномерноего кода
3. Добавляем фичи( команды для юза )
   * jmp ( метки )
   * оперативка
   * регистры
   * указатели
   * ввод вывод

### Тесты

1. Простые операции
   * сложение
   * и т.д
2. Линейное уравнение
3. Квадратное уравнение
4. Ипользование условий

>ну и добавить фичи!!!

## Набираемся смелости и добавляем возможность процессору решать квадратные уровнения

Для этого нудно сделать комнаду вычисления корня и как-то хранить дискриминант и корень

_для решения квадратного уровнения заведем **переменные - регистры**_

тогда наш код будет таким где

```c
push 5  
push ax  // ax добавим в стек
pop bx // pop из стека и положить в bx
```

что в байт коде будет

```c
1 5
1 1 1 // где 1 - номер команды 1 - говорит что это регистр 1 - гворит что это регистр с номером 1
2 1 2
```

### А что делать если у нас много данных

Запишем данные в оперативную память. Так будем иметь номер по которому лежит число - те указатель

```c
push [50] // создаем массив где 50 указатель на элемент в оперативке .. просто отдельный массив
psuh [ax]
```

в байт коде

```c
1 2 50 // где второй элемент это формат
2 2 1 // push оперативка регистр 1
```

#### пример

```c
push 49 // тут формат команды 0 - стек
pop ax  // тут формат 1 - регистр
push [ax] // тут формат комнанды 2 - элемент из оперативки
push [bx+4] // тут формат команды 4 в байт *1 4 2 4*
```

_тут мы просто пихаем в стек 49, достаем и пишем в регистр ax
далее просто пишем в стек элемент ax из оперативки_

## Ну а теперь прямо жесть. Введем уловия - If

Рассмотрим код

```c
push 1
pop ax // ax = 1

push ax
push ax
mul
out // out(ax^2)

push ax
push 1
add
pop ax // ax++

jmp // goto
```

теперь рассмотрим как это выглядит в байт коде в виде стека

```b
1 1 // ячейка 0 и 1
10 1 // 2 и 3
11 1 // вот и наша 4, те будет исполнятся команда 11 при переходе на 4
11 1
2
2
11
1
1
1
4
10
1
20 4 // прыгнуть на место 4 , те на 4 команд
```

но как вычеслить номер команды 4
Все просто. Сделайте код и поставте вместо 4 любое плохое число, как пример -1. После компиляции посмотрите на байт код и определите место в стеке команд, куда нужно перейти.

можно ip = 4 = pc[ip + 1]
 ***

### Метки

В наш код добавим метки вида

```с
:1 // метка 1
```

эти метки не переходят в байт код, а лишь вычисляются при компиляции.
Они будут заменены при компиляции на номер строки. Тогда такой код будет обработан и в него будет записан номер строки вместо метки

```asm
jmp :1
```

заменится на средствами компилятора, те ассемблера

```bin
jmp 4
```

***

### Логика компилятора

Идеи по коду и пропускаем при нумерации команд.
Заведем массив, где будем хранить сами метки. Тогда просто при появлении метки номер 1.

_**внимание** код в ASCII_
таким образом метки нужно привести к числам

```c
labels[str[1] - '0'] = cur_adress; // запишет в массив с метками метку с номером 1 и содержит текущий аддрес
```

полезно вывести появление метки **листинг**

#### Что делать если метка ниже по коду?

Прведем компиляции 2 раза. Построим массив месток при первом проходе. Далее при втором проходе уже раставим корректные адреса переходов по уже построенному массиву меток.

**массив меток** изначально заполнен **-1** те, при первом проходе у нас у меток будут адреса -1. При втором проходе испозуем уже созданый массив и заменим все -1 на корректный адреса.

>важно!

используем одну и туже функцию компиляции для повторного прохода

***

### Ну а теперь сами If

Разберем на примере

```c
push 1
pop ax // ax = 1
:1 // метка 1
push ax
push 100
ja :2 // берем последние 2 числа из стека. Сравнивам и если больше то переходим на метку 2

push ax
push ax
mul
out // out(ax^2)

push ax
push 1
add
pop ax // ax++

jmp :1// переход на метку 1
```

есть 3 различный if:

```c
// jump above
ja // if >
// jump below
jb // if <  
// jump equal
je // if ==
```

***

#### Как выйти из программы

```c
end // выход
```

***

#### Intresting

[посмотри](http://allegedly.petebevin.com/opcodes.html)

>команды acm, но интересней

***

## Пока все, короч...

>записано ПО "Деду"